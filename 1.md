# mailer

## Design prototyping

Below is a **simple, working Go prototype** of a CLI mailer that:

* Sends an email via command-line flags
* Supports providing either direct parameters (`--to`, `--subject`, `--body`)
* Or loading a raw `.eml` file and sending it as-is
* Uses the same package you already used (`gomail.v2`)
* Keeps everything minimal and low-level enough without unnecessary abstraction

---

# ✅ **Go Program: `mailer.go`**

```go
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	gomail "gopkg.in/gomail.v2"
)

func sendMail(smtpHost string, smtpPort int, username, password, from, to, subject, body string) error {
	m := gomail.NewMessage()
	m.SetHeader("From", from)
	m.SetHeader("To", to)
	m.SetHeader("Subject", subject)
	m.SetBody("text/plain", body)

	d := gomail.NewDialer(smtpHost, smtpPort, username, password)
	return d.DialAndSend(m)
}

func sendRawEML(smtpHost string, smtpPort int, username, password string, emlPath string) error {
	raw, err := ioutil.ReadFile(emlPath)
	if err != nil {
		return err
	}

	d := gomail.NewDialer(smtpHost, smtpPort, username, password)
	s, err := d.Dial()
	if err != nil {
		return err
	}

	defer s.Close()
	return gomail.Send(s, gomail.NewMessage(gomail.SetCharset("UTF-8"), gomail.SetBody("text/plain", string(raw))))
}

func main() {
	// Common SMTP configuration
	smtpHost := flag.String("host", "smtp.example.com", "SMTP server host")
	smtpPort := flag.Int("port", 587, "SMTP server port")
	username := flag.String("user", "", "SMTP username")
	password := flag.String("pass", "", "SMTP password")
	from := flag.String("from", "", "From email address")

	// Direct send mode
	to := flag.String("to", "", "Recipient email address")
	subject := flag.String("subject", "", "Email subject")
	body := flag.String("body", "", "Email body")

	// Raw .eml mode
	emlFile := flag.String("eml", "", "Path to raw EML file")

	flag.Parse()

	if *emlFile != "" {
		// Use raw EML mode
		if err := sendRawEML(*smtpHost, *smtpPort, *username, *password, *emlFile); err != nil {
			log.Fatalf("EML send failed: %v", err)
		}
		fmt.Println("Sent .eml successfully")
		return
	}

	// Normal mode requires to/subject/body
	if *to == "" || *subject == "" || *body == "" {
		fmt.Println("Missing arguments: --to, --subject, --body or --eml must be provided")
		flag.Usage()
		os.Exit(1)
	}

	if !strings.Contains(*from, "@") {
		log.Fatalf("Invalid --from email address")
	}

	err := sendMail(*smtpHost, *smtpPort, *username, *password, *from, *to, *subject, *body)
	if err != nil {
		log.Fatalf("Send failed: %v", err)
	}

	fmt.Println("Mail sent successfully")
}
```

---

# ✅ **Example Usage**

### **1. Normal email sending**

```
mailer \
  --host smtp.example.com \
  --port 587 \
  --user me@example.com \
  --pass secret \
  --from me@example.com \
  --to user@domain.com \
  --subject "Hello" \
  --body "This is a test"
```

### **2. Send a raw `.eml`**

```
mailer \
  --host smtp.example.com \
  --port 587 \
  --user me@example.com \
  --pass secret \
  --eml ./test.eml
```

---

# Extension needed
  - Make it prod-ready with a help, version, etc screen, the help screen should please a modern UI/UX dev with a nice ascii art.
  - In case the host, port and other creds are not provided in the flags then try to get it from `~/.config/mailer` if it is not there then fail.
  - Make sure that the eml file is being handled properly.
  - I also want to make a .so [or the static version of .so (I forgot the extension)] version which other programs can link against and use the functionality.
  - Also make sure to handle proper email convention and don't miss out on features, (examples: Username <user@name.com>) (I will test you and see if you handled other things that I did not mention explicitely so make sure you take care)
